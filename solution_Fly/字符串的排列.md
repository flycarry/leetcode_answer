#### 题目：

给定两个字符串 **s1** 和 **s2**，写一个函数来判断 **s2** 是否包含 **s1** 的排列。

换句话说，第一个字符串的排列之一是第二个字符串的子串。

**示例1:**

```
输入: s1 = "ab" s2 = "eidbaooo"
输出: True
解释: s2 包含 s1 的排列之一 ("ba").
```

 

**示例2:**

```
输入: s1= "ab" s2 = "eidboaoo"
输出: False
```



#### 解析：

我们来分析题目，这道题我们观察，首先s2肯定是要遍历一遍的，所以采用循环的方式来进行主要逻辑的实现，然后考虑我们在循环的时候需要保存和比较什么数据，就是说，我们在下一个元素的时候需要用到之前的什么数据，几个数据，可以看出，对于两个字符串的排列是否一样，用计数器肯定是最好的，讲遍历的时候每个元素的后s1数量个字符和s1比较是最简单的，但是我们发现，这样每个元素重复计算了s1次，不是很科学。所以我们要思考如何把之前的匹配保存下来，就使用了除map外一个匹配计数器，每次匹配一个以后加1，加到s1的时候就是匹配，所以就可以使用s1的时间复杂度完成了数据。



#### 解答：

```go
func checkInclusion(s1 string, s2 string) bool {
	if len(s1)>len(s2){
		return false
	}
	m := make(map[uint8]int)
	e := 0
	for i := 0; i < len(s1); i++ {
		m[s1[i]]++
	}
	for i := 0; i < len(s1); i++ {
		m[s2[i]]--
		if m[s2[i]] >= 0 {
			e++
		}
	}
	if e == len(s1) {
		return true
	}
	for i := len(s1); i < len(s2); i++ {
		if m[s2[i-len(s1)]] >= 0 {
			e--
		}
		m[s2[i-len(s1)]]++
		if m[s2[i]]>0{
			e++
		}
		m[s2[i]]--
		if e==len(s1){
			return true
		}
	}
	return false
}
```

#### 结论：

时间复杂度：O(n)

空间复杂度：O(n)

主要使用了哈希表数据结构