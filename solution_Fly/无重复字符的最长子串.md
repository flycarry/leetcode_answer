#### 题目：

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

#### 解析：

可以看出，首先这个方法至少要遍历一遍字符串的每个字符，其次，考虑是否可以通过只遍历一遍字符串得到答案，然后可以看出，遍历的时候需要记录的状态有，当前有效空间的长度，还有之前是否有重复的字符，以及重复字符后新有效空间的长度从何开始，类似kmp算法，可以采用索引的方式记录有效空间损耗后的新空间开始地址，然后检索重复可以想到使用map作为数据结构，所以就可以顺势考虑出这样的方式来存储数据。

#### 代码：

```go
func lengthOfLongestSubstring(s string) int {
	lens:=len(s)
	min:=0
	max:=0
	m:=make(map[uint8]int)
	for i := 0; i < lens; i++ {
		v,exist:=m[s[i]]
		max2:=0
		if v<min{
			exist=false
		}
		if exist{
			m[s[i]]=i
			max2=i-min
			min=v+1

		}else {
			m[s[i]]=i
			if i==lens-1{
				max2=i-min+1
			}
		}
		if max<max2{
			max=max2
		}
	}
	return max
}

```

#### 结论：

空间复杂度：O（n）

时间复杂度：O（n）